<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»™XiuRong Yançš„åœ£è¯ç¤¼ç‰© ğŸ„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #2c1810, #8b0000, #dc143c);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .title {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: center;
            pointer-events: auto;
            background: linear-gradient(45deg, #ffd700, #ffb347, #ff69b4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 5px rgba(255,215,0,0.5)); }
            to { filter: drop-shadow(0 0 20px rgba(255,105,180,0.8)); }
        }

        .subtitle {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: center;
            pointer-events: auto;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(15px);
            padding: 20px 30px;
            border-radius: 25px;
            color: #fff;
            font-size: 1em;
            text-align: center;
            pointer-events: auto;
            border: 2px solid rgba(255,215,0,0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .gesture-indicator {
            position: absolute;
            top: 200px;
            right: 50px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            color: #fff;
            font-size: 1em;
            pointer-events: auto;
            border: 1px solid rgba(255,215,0,0.2);
        }

        .photo-upload {
            position: absolute;
            top: 30px;
            right: 30px;
            pointer-events: auto;
        }

        .upload-btn {
            background: linear-gradient(45deg, #ff69b4, #ffb347);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255,105,180,0.3);
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,105,180,0.5);
        }

        .romantic-message {
            position: absolute;
            bottom: 150px;
            left: 50px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            color: #fff;
            font-size: 1.1em;
            font-style: italic;
            pointer-events: auto;
            border: 1px solid rgba(255,215,0,0.2);
            max-width: 300px;
        }

        .hearts {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .heart {
            position: absolute;
            color: rgba(255,105,180,0.8);
            font-size: 24px;
            animation: floatHearts 8s infinite linear;
        }

        @keyframes floatHearts {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.5em;
            text-align: center;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading" id="loading">
            <div>æ­£åœ¨ä¸ºä½ å‡†å¤‡åœ£è¯é­”æ³•... âœ¨</div>
            <div style="margin-top: 10px; font-size: 0.8em;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
        </div>
        
        <div id="ui-overlay" class="hidden">
            <h1 class="title">ç»™æœ€ç¾ä¸½çš„XiuRong Yan ğŸ„</h1>
            <p class="subtitle">æ„¿æˆ‘ä»¬çš„çˆ±æƒ…å¦‚è¿™åœ£è¯æ ‘èˆ¬æ°¸æ’é—ªè€€</p>
            
            <div class="gesture-indicator">
                <div>å½“å‰æ‰‹åŠ¿: <span id="gesture-status">æ£€æµ‹ä¸­...</span></div>
                <div style="margin-top: 5px; font-size: 0.9em; opacity: 0.8;">
                    ğŸ–ï¸ å¼ å¼€æ‰‹æŒ - æ•£å¼€æ¨¡å¼<br>
                    âœŠ æ¡æ‹³ - åˆæ‹¢æ¨¡å¼<br>
                    ğŸ¤ æåˆ - æ”¾å¤§ç…§ç‰‡
                </div>
            </div>
            
            <div class="photo-upload">
                <input type="file" id="photo-input" accept="image/*" multiple style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('photo-input').click()">
                    ğŸ“¸ ä¸Šä¼ æˆ‘ä»¬çš„ç…§ç‰‡
                </button>
            </div>
            
            <div class="romantic-message">
                "æ¯ä¸€ä¸ªç²’å­éƒ½ä»£è¡¨ç€æˆ‘å¯¹ä½ çš„çˆ±æ„<br>
                æ¯ä¸€å¼ ç…§ç‰‡éƒ½æ˜¯æˆ‘ä»¬çš„ç¾å¥½å›å¿†<br>
                æ„¿ä½ åœ¨è¿™ä¸ªåœ£è¯èŠ‚æ„Ÿå—åˆ°æˆ‘æ»¡æ»¡çš„çˆ± ğŸ’•"
            </div>
            
            <div class="controls">
                <div>ğŸ® æ‰‹åŠ¿æ§åˆ¶è¯´æ˜</div>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    å¼ å¼€æ‰‹æŒæ•£å¼€ç²’å­ | æ¡æ‹³èšåˆåœ£è¯æ ‘ | æåˆæ‰‹åŠ¿æŸ¥çœ‹ç…§ç‰‡
                </div>
                <div style="margin-top: 5px; font-size: 0.8em; opacity: 0.7;">
                    é¼ æ ‡ä¹Ÿå¯æ“ä½œï¼šæ‹–æ‹½æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | Hé”®éšè—UI
                </div>
            </div>
        </div>
        
        <div class="hearts" id="hearts-container"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
        
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let treeParticles, photoParticles;
        let particleSystem, photoSystem;
        let currentState = 'gathered'; // gathered, scattered, photo
        let targetState = 'gathered';
        let gestureRecognizer;
        let videoElement;
        let animationId;
        let photos = [];
        let selectedPhoto = null;
        let romanticTexts = [];
        
        // æ‰‹åŠ¿çŠ¶æ€
        let handState = {
            gesture: 'none',
            rotation: { x: 0, y: 0 },
            pinching: false,
            handPosition: { x: 0, y: 0 }
        };

        // åˆå§‹åŒ–åœºæ™¯
        async function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x2c1810, 50, 200);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 50);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x2c1810, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // åˆ›å»ºæ§åˆ¶å™¨
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 100;
            controls.minDistance = 20;
            
            // æ·»åŠ ç¯å…‰
            setupLights();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            await createParticleSystems();
            
            // åˆå§‹åŒ–MediaPipeæ‰‹åŠ¿è¯†åˆ«
            await initGestureRecognition();
            
            // åˆ›å»ºé£˜è½çš„çˆ±å¿ƒ
            createFloatingHearts();
            
            // éšè—åŠ è½½ç•Œé¢
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('ui-overlay').classList.remove('hidden');
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }

        // è®¾ç½®ç¯å…‰
        function setupLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // åœ£è¯ç¯å…‰æ•ˆæœ
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff69b4, 0x00ffff];
            for (let i = 0; i < 20; i++) {
                const pointLight = new THREE.PointLight(colors[i % colors.length], 0.6, 30);
                const angle = (i / 20) * Math.PI * 2;
                pointLight.position.set(
                    Math.cos(angle) * 25,
                    10 + Math.sin(i * 0.5) * 8,
                    Math.sin(angle) * 25
                );
                scene.add(pointLight);
            }
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        async function createParticleSystems() {
            // åœ£è¯æ ‘ç²’å­ç³»ç»Ÿ
            const particleCount = 8000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);
            
            // åˆ›å»ºåœ£è¯æ ‘å½¢çŠ¶
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // åœ£è¯æ ‘å½¢çŠ¶ç®—æ³•
                const y = Math.random() * 25 - 12.5;
                const radius = Math.max(0.5, (12.5 - Math.abs(y)) * 0.6);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                
                positions[i3] = Math.cos(angle) * r;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(angle) * r;
                
                // åœ£è¯è‰²å½©
                const colorChoice = Math.random();
                if (colorChoice < 0.6) {
                    // ç»¿è‰²
                    colors[i3] = 0.1 + Math.random() * 0.3;
                    colors[i3 + 1] = 0.6 + Math.random() * 0.4;
                    colors[i3 + 2] = 0.1 + Math.random() * 0.3;
                } else if (colorChoice < 0.8) {
                    // é‡‘è‰²
                    colors[i3] = 0.8 + Math.random() * 0.2;
                    colors[i3 + 1] = 0.6 + Math.random() * 0.4;
                    colors[i3 + 2] = 0.1 + Math.random() * 0.3;
                } else {
                    // çº¢è‰²
                    colors[i3] = 0.8 + Math.random() * 0.2;
                    colors[i3 + 1] = 0.1 + Math.random() * 0.3;
                    colors[i3 + 2] = 0.1 + Math.random() * 0.3;
                }
                
                sizes[i] = Math.random() * 3 + 1;
                
                // åˆå§‹é€Ÿåº¦
                velocities[i3] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            
            // åˆ›å»ºæè´¨
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // ä¿å­˜åŸå§‹ä½ç½®
            particleSystem.userData.originalPositions = positions.slice();
            particleSystem.userData.velocities = velocities.slice();
        }

        // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
        async function initGestureRecognition() {
            try {
                // åˆ›å»ºè§†é¢‘å…ƒç´ 
                videoElement = document.createElement('video');
                videoElement.style.display = 'none';
                document.body.appendChild(videoElement);
                
                // è·å–æ‘„åƒå¤´æƒé™
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 }
                });
                videoElement.srcObject = stream;
                videoElement.play();
                
                // åŠ è½½MediaPipeæ‰‹åŠ¿è¯†åˆ«æ¨¡å‹
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
                );
                
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-tasks/gesture_recognizer/gesture_recognizer.task",
                        delegate: "GPU"
                    },
                    numHands: 2,
                    runningMode: "VIDEO"
                });
                
                // å¼€å§‹æ‰‹åŠ¿æ£€æµ‹å¾ªç¯
                detectGestures();
                
            } catch (error) {
                console.warn('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨é¼ æ ‡æ§åˆ¶æ¨¡å¼:', error);
                // å¦‚æœæ‰‹åŠ¿è¯†åˆ«å¤±è´¥ï¼Œä»ç„¶å¯ä»¥ä½¿ç”¨é¼ æ ‡æ§åˆ¶
            }
        }

        // æ‰‹åŠ¿æ£€æµ‹
        function detectGestures() {
            if (!gestureRecognizer || !videoElement) return;
            
            const detect = async () => {
                if (videoElement.readyState >= 2) {
                    try {
                        const results = gestureRecognizer.recognizeForVideo(videoElement, Date.now());
                        
                        if (results.gestures && results.gestures.length > 0) {
                            const gesture = results.gestures[0][0].categoryName;
                            const landmarks = results.landmarks[0];
                            
                            updateHandState(gesture, landmarks);
                        } else {
                            handState.gesture = 'none';
                        }
                    } catch (error) {
                        console.warn('æ‰‹åŠ¿æ£€æµ‹é”™è¯¯:', error);
                    }
                }
                
                requestAnimationFrame(detect);
            };
            
            detect();
        }

        // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€
        function updateHandState(gesture, landmarks) {
            const previousGesture = handState.gesture;
            handState.gesture = gesture;
            
            // æ›´æ–°UIæ˜¾ç¤º
            updateGestureUI(gesture);
            
            // æ ¹æ®æ‰‹åŠ¿æ›´æ–°çŠ¶æ€
            switch (gesture) {
                case 'Open_Palm': // å¼ å¼€æ‰‹æŒ
                    targetState = 'scattered';
                    break;
                case 'Closed_Fist': // æ¡æ‹³
                    targetState = 'gathered';
                    break;
                case 'Pinch': // æåˆ
                    if (!handState.pinching) {
                        handState.pinching = true;
                        selectRandomPhoto();
                    }
                    break;
                default:
                    handState.pinching = false;
            }
            
            // æ›´æ–°æ‰‹éƒ¨æ—‹è½¬
            if (landmarks && landmarks.length > 0) {
                const wrist = landmarks[0];
                const middleFinger = landmarks[12];
                
                handState.rotation.x = (wrist.y - 0.5) * 2;
                handState.rotation.y = (wrist.x - 0.5) * 2;
                handState.handPosition.x = wrist.x;
                handState.handPosition.y = wrist.y;
                
                // åœ¨æ•£å¼€çŠ¶æ€ä¸‹ï¼Œç”¨æ‰‹æ§åˆ¶ç›¸æœºæ—‹è½¬
                if (currentState === 'scattered') {
                    const rotationSpeed = 0.02;
                    controls.autoRotate = false;
                    camera.position.x = Math.sin(handState.rotation.y * Math.PI) * 50;
                    camera.position.z = Math.cos(handState.rotation.y * Math.PI) * 50;
                    camera.position.y = 20 + handState.rotation.x * 20;
                    camera.lookAt(0, 0, 0);
                }
            }
        }

        // æ›´æ–°æ‰‹åŠ¿UI
        function updateGestureUI(gesture) {
            const statusElement = document.getElementById('gesture-status');
            const gestureNames = {
                'Open_Palm': 'ğŸ–ï¸ å¼ å¼€æ‰‹æŒ',
                'Closed_Fist': 'âœŠ æ¡æ‹³',
                'Pinch': 'ğŸ¤ æåˆ',
                'none': 'âŒ æ— æ£€æµ‹'
            };
            statusElement.textContent = gestureNames[gesture] || gesture;
        }

        // é€‰æ‹©éšæœºç…§ç‰‡
        function selectRandomPhoto() {
            if (photos.length > 0) {
                selectedPhoto = photos[Math.floor(Math.random() * photos.length)];
                targetState = 'photo';
                setTimeout(() => {
                    targetState = currentState;
                }, 3000);
            }
        }

        // åˆ›å»ºé£˜è½çš„çˆ±å¿ƒ
        function createFloatingHearts() {
            const heartsContainer = document.getElementById('hearts-container');
            
            setInterval(() => {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.textContent = 'ğŸ’–';
                heart.style.left = Math.random() * 100 + '%';
                heart.style.animationDuration = (Math.random() * 3 + 5) + 's';
                heart.style.fontSize = (Math.random() * 10 + 20) + 'px';
                
                heartsContainer.appendChild(heart);
                
                setTimeout(() => {
                    heart.remove();
                }, 8000);
            }, 2000);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // æ›´æ–°ç²’å­çŠ¶æ€
            updateParticles();
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // æ›´æ–°ç²’å­ç³»ç»Ÿ
        function updateParticles() {
            if (!particleSystem) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const originalPositions = particleSystem.userData.originalPositions;
            const velocities = particleSystem.userData.velocities;
            const time = Date.now() * 0.001;
            
            // çŠ¶æ€è½¬æ¢åŠ¨ç”»
            const lerpFactor = 0.02;
            
            for (let i = 0; i < positions.length; i += 3) {
                let targetX, targetY, targetZ;
                
                if (targetState === 'scattered') {
                    // æ•£å¼€çŠ¶æ€ - æ˜Ÿäº‘æ•ˆæœ
                    const angle = time * 0.5 + i * 0.01;
                    const radius = 30 + Math.sin(time + i * 0.1) * 10;
                    targetX = Math.cos(angle) * radius;
                    targetY = Math.sin(time + i * 0.05) * 15;
                    targetZ = Math.sin(angle) * radius;
                } else if (targetState === 'photo' && selectedPhoto) {
                    // ç…§ç‰‡å±•ç¤ºçŠ¶æ€
                    targetX = originalPositions[i] + (Math.random() - 0.5) * 5;
                    targetY = originalPositions[i + 1] + 10;
                    targetZ = originalPositions[i + 2] + (Math.random() - 0.5) * 5;
                } else {
                    // èšåˆçŠ¶æ€ - åœ£è¯æ ‘
                    targetX = originalPositions[i];
                    targetY = originalPositions[i + 1];
                    targetZ = originalPositions[i + 2];
                }
                
                // å¹³æ»‘æ’å€¼
                positions[i] += (targetX - positions[i]) * lerpFactor;
                positions[i + 1] += (targetY - positions[i + 1]) * lerpFactor;
                positions[i + 2] += (targetZ - positions[i + 2]) * lerpFactor;
                
                // æ·»åŠ è½»å¾®çš„å‘¼å¸æ•ˆæœ
                positions[i + 1] += Math.sin(time * 2 + i * 0.1) * 0.1;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            currentState = targetState;
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // å¤„ç†ç…§ç‰‡ä¸Šä¼ 
        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (!files) return;
            
            for (let file of files) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    photos.push(e.target.result);
                    // è¿™é‡Œå¯ä»¥æ·»åŠ å°†ç…§ç‰‡è½¬æ¢ä¸º3Dç²’å­çš„é€»è¾‘
                };
                reader.readAsDataURL(file);
            }
        }

        // é”®ç›˜äº‹ä»¶å¤„ç†
        function onKeyPress(event) {
            switch(event.key.toLowerCase()) {
                case 'h':
                    document.getElementById('ui-overlay').classList.toggle('hidden');
                    break;
                case ' ':
                    targetState = targetState === 'scattered' ? 'gathered' : 'scattered';
                    break;
            }
        }

        // é”™è¯¯å¤„ç†
        window.addEventListener('error', function(event) {
            console.error('å‘ç”Ÿé”™è¯¯:', event.error);
            document.getElementById('loading').innerHTML = 
                '<div>åŠ è½½é‡åˆ°é—®é¢˜ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯• ğŸ˜¢</div>' +
                '<div style="margin-top: 10px; font-size: 0.8em;">è¯·ç¡®ä¿æµè§ˆå™¨æ”¯æŒWebGLå’Œæ‘„åƒå¤´</div>';
        });

        // äº‹ä»¶ç›‘å¬å™¨
        window.addEventListener('resize', onWindowResize);
        document.getElementById('photo-input').addEventListener('change', handlePhotoUpload);
        document.addEventListener('keydown', onKeyPress);
        
        // åŠ è½½å¿…è¦çš„åº“
        const script = document.createElement('script');
        script.type = 'module';
        script.textContent = `
            import { FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';
            window.FilesetResolver = FilesetResolver;
        `;
        document.head.appendChild(script);
        
        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('load', init);
        
        // æ·»åŠ ä¸€äº›æµªæ¼«çš„æ–‡å­—
        const romanticQuotes = [
            "çˆ±æ˜¯åœ£è¯èŠ‚çš„çœŸè°›ï¼Œè€Œä½ æ˜¯æˆ‘ç”Ÿå‘½ä¸­æœ€ç¾çš„ç¤¼ç‰©",
            "æ¯ä¸€ä¸ªç²’å­éƒ½åœ¨è¯‰è¯´ç€æˆ‘å¯¹ä½ çš„æ€å¿µ",
            "æ„¿æˆ‘ä»¬çš„çˆ±æƒ…å¦‚åœ£è¯æ ‘èˆ¬é•¿é’ä¸è´¥",
            "åœ¨è¿™ä¸ªç‰¹åˆ«çš„æ—¥å­é‡Œï¼Œåªæƒ³ç‰µç€ä½ çš„æ‰‹çœ‹é›ªè½",
            "ä½ æ˜¯æˆ‘å¿ƒä¸­æœ€äº®çš„æ˜Ÿï¼Œç…§äº®æˆ‘æ‰€æœ‰çš„åœ£è¯å¤œ"
        ];
        
        // å®šæœŸæ›´æ–°æµªæ¼«æ–‡å­—
        setInterval(() => {
            const messageElement = document.querySelector('.romantic-message');
            const randomQuote = romanticQuotes[Math.floor(Math.random() * romanticQuotes.length)];
            messageElement.innerHTML = `"${randomQuote}"<br><br>"æ„¿è¿™ä¸ªåœ£è¯èŠ‚ï¼Œæˆ‘ä»¬çš„çˆ±æ°¸æ’é—ªè€€ ğŸ’•"`;
        }, 10000);
    </script>
</body>
</html>