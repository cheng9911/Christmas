<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Magic for XiuRong Yan üéÑüéÑüéÑ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #2c1810, #8b0000, #dc143c);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .title {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: center;
            pointer-events: auto;
            background: linear-gradient(45deg, #ffd700, #ffb347, #ff69b4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 5px rgba(255,215,0,0.5)); }
            to { filter: drop-shadow(0 0 20px rgba(255,105,180,0.8)); }
        }

        .subtitle {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: center;
            pointer-events: auto;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(15px);
            padding: 20px 30px;
            border-radius: 25px;
            color: #fff;
            font-size: 1em;
            text-align: center;
            pointer-events: auto;
            border: 2px solid rgba(255,215,0,0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .gesture-indicator {
            position: absolute;
            top: 200px;
            right: 50px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            color: #fff;
            font-size: 1em;
            pointer-events: auto;
            border: 1px solid rgba(255,215,0,0.2);
        }

        .photo-upload {
            position: absolute;
            top: 30px;
            right: 30px;
            pointer-events: auto;
        }

        .upload-btn {
            background: linear-gradient(45deg, #ff69b4, #ffb347);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255,105,180,0.3);
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,105,180,0.5);
        }

        .romantic-message {
            position: absolute;
            bottom: 150px;
            left: 50px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            color: #fff;
            font-size: 1.1em;
            font-style: italic;
            pointer-events: auto;
            border: 1px solid rgba(255,215,0,0.2);
            max-width: 300px;
        }

        .hearts {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .heart {
            position: absolute;
            color: rgba(255,105,180,0.8);
            font-size: 24px;
            animation: floatHearts 8s infinite linear;
        }

        @keyframes floatHearts {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.5em;
            text-align: center;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading" id="loading">
            <div>‚ú® Preparing Christmas Magic for XiuRong Yan... ‚ú®‚ú®</div>
            <button id="start-experience" class="upload-btn" style="margin-top: 20px;">
                üéÑüéÑüéÑ Start Experience & Enable Camera
            </button>
            <div style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                Please allow camera access when prompted.
            </div>
        </div>
        
        <div id="ui-overlay" class="hidden">
            <h1 class="title">Merry Christmas, My Dearest XiuRong Yan üéÑüéÑüéÑ</h1>
            <p class="subtitle">A magical tree of love, controlled by your hand.</p>
            
            <div class="gesture-indicator">
                <div>Current Gesture: <span id="gesture-status">Detecting...</span></div>
                <div style="margin-top: 5px; font-size: 0.9em; opacity: 0.8;">
                    üñêüñêüñêÔ∏è Open Palm - Scatter Mode<br>
                    ‚úä‚úä Closed Fist - Gather Mode<br>
                    ü§èü§è Pinch - View Photo
                </div>
            </div>
            
            <div class="photo-upload">
                <input type="file" id="photo-input" accept="image/*" multiple style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('photo-input').click()">
                    üì∏üì∏ Upload Our Memories
                </button>
            </div>
            
            <div class="romantic-message">
                "Áà±ÊòØÂú£ËØûËäÇÁöÑÁúüË∞õÔºåËÄå‰Ω†ÊòØÊàëÁîüÂëΩ‰∏≠ÊúÄÁæéÁöÑÁ§ºÁâ© üíïüíï"
            </div>
            
            <div class="controls">
                <div>üéÆüéÆ Gesture Controls</div>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    Open palm to scatter | Closed fist to gather | Pinch to view photo
                </div>
                <div style="margin-top: 5px; font-size: 0.8em; opacity: 0.7;">
                    Mouse also works: Drag to rotate | Scroll to zoom | H key to hide UI
                </div>
            </div>
        </div>
        
        <div class="hearts" id="hearts-container"></div>
    </div>

    <!-- ‰øÆÂ§çÔºöÊ∑ªÂä†MediaPipeÁöÑËÑöÊú¨ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
        
        // Global variables
        let scene, camera, renderer, controls;
        let particleSystem;
        let currentState = 'gathered'; // gathered, scattered, photo
        let targetState = 'gathered';
        let handGestureRecognizer;
        let videoElement;
        let animationId;
        let photos = [];
        let selectedPhoto = null;
        
        // Hand gesture state
        let handState = {
            gesture: 'none',
            rotation: { x: 0, y: 0 },
            pinching: false,
            handPosition: { x: 0, y: 0 }
        };

        // Initialize scene
        async function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x2c1810, 50, 200);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 50);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x2c1810, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Create controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 100;
            controls.minDistance = 20;
            
            // Add lights
            setupLights();
            
            // Create particle systems
            await createParticleSystems();
            
            // Create floating hearts
            createFloatingHearts();
            
            // Event listeners
            setupEventListeners();
            
            // Start animation
            animate();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Start experience button
            document.getElementById('start-experience').addEventListener('click', async () => {
                try {
                    // Create video element for gesture recognition
                    videoElement = document.createElement('video');
                    videoElement.style.display = 'none';
                    videoElement.setAttribute('playsinline', 'true');
                    videoElement.setAttribute('muted', 'true');
                    document.body.appendChild(videoElement);
                    
                    // Get camera permission with better error handling
                    const constraints = {
                        video: { 
                            width: { ideal: 640 }, 
                            height: { ideal: 480 },
                            facingMode: 'user'
                        } 
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = stream;
                    
                    // Wait for video to be ready
                    await new Promise((resolve) => {
                        videoElement.onloadedmetadata = () => {
                            videoElement.play();
                            resolve();
                        };
                    });
                    
                    // Hide loading screen
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('ui-overlay').classList.remove('hidden');
                    
                    // Initialize gesture recognition
                    await initHandGestureRecognition();
                    
                } catch (error) {
                    console.error("Camera access denied:", error);
                    document.getElementById('loading').innerHTML = `
                        <div>‚ùå‚ùå Unable to access camera.</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">
                            Please ensure camera permissions are enabled and try again.
                            <br>Error: ${error.message}
                        </div>
                        <button class="upload-btn" style="margin-top: 20px;" onclick="location.reload()">
                            üîÑ Retry
                        </button>`;
                }
            });
            
            // Photo upload
            document.getElementById('photo-input').addEventListener('change', handlePhotoUpload);
            
            // Keyboard events
            document.addEventListener('keydown', onKeyPress);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Setup lights
        function setupLights() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Christmas lights
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff69b4, 0x00ffff];
            for (let i = 0; i < 20; i++) {
                const pointLight = new THREE.PointLight(colors[i % colors.length], 0.6, 30);
                const angle = (i / 20) * Math.PI * 2;
                pointLight.position.set(
                    Math.cos(angle) * 25,
                    10 + Math.sin(i * 0.5) * 8,
                    Math.sin(angle) * 25
                );
                scene.add(pointLight);
            }
        }

        // Create particle systems
        async function createParticleSystems() {
            const particleCount = 8000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);
            
            // Create Christmas tree shape
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Christmas tree shape algorithm
                const y = Math.random() * 25 - 12.5;
                const radius = Math.max(0.5, (12.5 - Math.abs(y)) * 0.6);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                
                positions[i3] = Math.cos(angle) * r;
                positions[i3 + 1] = y;
                positions[i3 + 2] = Math.sin(angle) * r;
                
                // Christmas colors
                const colorChoice = Math.random();
                if (colorChoice < 0.6) {
                    // Green
                    colors[i3] = 0.1 + Math.random() * 0.3;
                    colors[i3 + 1] = 0.6 + Math.random() * 0.4;
                    colors[i3 + 2] = 0.1 + Math.random() * 0.3;
                } else if (colorChoice < 0.8) {
                    // Gold
                    colors[i3] = 0.8 + Math.random() * 0.2;
                    colors[i3 + 1] = 0.6 + Math.random() * 0.4;
                    colors[i3 + 2] = 0.1 + Math.random() * 0.3;
                } else {
                    // Red
                    colors[i3] = 0.8 + Math.random() * 0.2;
                    colors[i3 + 1] = 0.1 + Math.random() * 0.3;
                    colors[i3 + 2] = 0.1 + Math.random() * 0.3;
                }
                
                sizes[i] = Math.random() * 3 + 1;
                
                // Initial velocities
                velocities[i3] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // Save original positions
            particleSystem.userData.originalPositions = positions.slice();
            particleSystem.userData.velocities = velocities.slice();
        }

        // Initialize hand gesture recognition using MediaPipe Hands
        async function initHandGestureRecognition() {
            try {
                handGestureRecognizer = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                handGestureRecognizer.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                handGestureRecognizer.onResults((results) => {
                    updateHandStateFromResults(results);
                });
                
                // Start processing video
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await handGestureRecognizer.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                camera.start();
                
            } catch (error) {
                console.warn('Hand gesture recognition initialization failed:', error);
                document.getElementById('gesture-status').textContent = 'Mouse Mode';
                // Fallback to mouse controls
                setupMouseGestureControls();
            }
        }

        // Update hand state from MediaPipe results
        function updateHandStateFromResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                handState.gesture = 'none';
                updateGestureUI('none');
                return;
            }
            
            const landmarks = results.multiHandLandmarks[0];
            const gestures = results.multiHandGestures ? results.multiHandGestures[0] : ['Unknown'];
            
            // Simple gesture detection based on hand landmarks
            const gesture = detectSimpleGesture(landmarks);
            handState.gesture = gesture;
            updateGestureUI(gesture);
            
            // Update state based on gesture
            switch (gesture) {
                case 'open_palm':
                    targetState = 'scattered';
                    break;
                case 'closed_fist':
                    targetState = 'gathered';
                    break;
                case 'pinch':
                    if (!handState.pinching) {
                        handState.pinching = true;
                        selectRandomPhoto();
                    }
                    break;
                default:
                    handState.pinching = false;
            }
            
            // Update hand position for camera control
            if (landmarks && landmarks.length > 0) {
                const wrist = landmarks[0];
                handState.rotation.x = (wrist.y - 0.5) * 2;
                handState.rotation.y = (wrist.x - 0.5) * 2;
                handState.handPosition.x = wrist.x;
                handState.handPosition.y = wrist.y;
                
                // Control camera rotation with hand in scattered state
                if (currentState === 'scattered') {
                    controls.autoRotate = false;
                    camera.position.x = Math.sin(handState.rotation.y * Math.PI) * 50;
                    camera.position.z = Math.cos(handState.rotation.y * Math.PI) * 50;
                    camera.position.y = 20 + handState.rotation.x * 20;
                    camera.lookAt(0, 0, 0);
                }
            }
        }

        // Simple gesture detection based on hand landmarks
        function detectSimpleGesture(landmarks) {
            if (!landmarks || landmarks.length < 21) return 'none';
            
            // Get key points
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // Calculate distances for pinch detection
            const thumbIndexDistance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) +
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            
            // Check for pinch gesture
            if (thumbIndexDistance < 0.05) {
                return 'pinch';
            }
            
            // Check if fingers are extended (open palm) or closed (fist)
            let extendedFingers = 0;
            
            // Check each finger tip distance from wrist
            const fingerTips = [indexTip, middleTip, ringTip, pinkyTip];
            for (const tip of fingerTips) {
                const distance = Math.sqrt(
                    Math.pow(tip.x - wrist.x, 2) +
                    Math.pow(tip.y - wrist.y, 2)
                );
                if (distance > 0.15) { // Threshold for extended finger
                    extendedFingers++;
                }
            }
            
            if (extendedFingers >= 3) {
                return 'open_palm';
            } else if (extendedFingers <= 1) {
                return 'closed_fist';
            }
            
            return 'none';
        }

        // Setup mouse gesture controls as fallback
        function setupMouseGestureControls() {
            let isMouseDown = false;
            let mouseStartX = 0;
            let mouseStartY = 0;
            
            document.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseStartX = e.clientX;
                mouseStartY = e.clientY;
                handState.gesture = 'closed_fist';
                targetState = 'gathered';
                updateGestureUI('closed_fist');
            });
            
            document.addEventListener('mouseup', (e) => {
                isMouseDown = false;
                const deltaX = Math.abs(e.clientX - mouseStartX);
                const deltaY = Math.abs(e.clientY - mouseStartY);
                
                if (deltaX < 10 && deltaY < 10) {
                    // Click without drag - treat as open palm
                    handState.gesture = 'open_palm';
                    targetState = 'scattered';
                    updateGestureUI('open_palm');
                    
                    // Auto return to gathered after 2 seconds
                    setTimeout(() => {
                        handState.gesture = 'closed_fist';
                        targetState = 'gathered';
                        updateGestureUI('closed_fist');
                    }, 2000);
                }
            });
            
            // Double click for pinch gesture
            document.addEventListener('dblclick', () => {
                handState.gesture = 'pinch';
                updateGestureUI('pinch');
                selectRandomPhoto();
                
                setTimeout(() => {
                    handState.gesture = 'none';
                    updateGestureUI('none');
                }, 1000);
            });
        }

        // Update gesture UI
        function updateGestureUI(gesture) {
            const statusElement = document.getElementById('gesture-status');
            const gestureNames = {
                'open_palm': 'üñêüñêüñêÔ∏è Open Palm',
                'closed_fist': '‚úä‚úä Closed Fist',
                'pinch': 'ü§èü§è Pinch',
                'none': '‚ùå‚ùå No Detection'
            };
            statusElement.textContent = gestureNames[gesture] || gesture;
        }

        // Select random photo
        function selectRandomPhoto() {
            if (photos.length > 0) {
                selectedPhoto = photos[Math.floor(Math.random() * photos.length)];
                targetState = 'photo';
                setTimeout(() => {
                    targetState = currentState;
                }, 3000);
            }
        }

        // Create floating hearts
        function createFloatingHearts() {
            const heartsContainer = document.getElementById('hearts-container');
            
            setInterval(() => {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.textContent = 'üíñüíñ';
                heart.style.left = Math.random() * 100 + '%';
                heart.style.animationDuration = (Math.random() * 3 + 5) + 's';
                heart.style.fontSize = (Math.random() * 10 + 20) + 'px';
                
                heartsContainer.appendChild(heart);
                
                setTimeout(() => {
                    heart.remove();
                }, 8000);
            }, 2000);
        }

        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Update particles
            updateParticles();
            
            // Update controls
            controls.update();
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Update particles
        function updateParticles() {
            if (!particleSystem) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const originalPositions = particleSystem.userData.originalPositions;
            const time = Date.now() * 0.001;
            
            // State transition animation
            const lerpFactor = 0.02;
            
            for (let i = 0; i < positions.length; i += 3) {
                let targetX, targetY, targetZ;
                
                if (targetState === 'scattered') {
                    // Scattered state - nebula effect
                    const angle = time * 0.5 + i * 0.01;
                    const radius = 30 + Math.sin(time + i * 0.1) * 10;
                    targetX = Math.cos(angle) * radius;
                    targetY = Math.sin(time + i * 0.05) * 15;
                    targetZ = Math.sin(angle) * radius;
                } else if (targetState === 'photo' && selectedPhoto) {
                    // Photo display state
                    targetX = originalPositions[i] + (Math.random() - 0.5) * 5;
                    targetY = originalPositions[i + 1] + 10;
                    targetZ = originalPositions[i + 2] + (Math.random() - 0.5) * 5;
                } else {
                    // Gathered state - Christmas tree
                    targetX = originalPositions[i];
                    targetY = originalPositions[i + 1];
                    targetZ = originalPositions[i + 2];
                }
                
                // Smooth interpolation
                positions[i] += (targetX - positions[i]) * lerpFactor;
                positions[i + 1] += (targetY - positions[i + 1]) * lerpFactor;
                positions[i + 2] += (targetZ - positions[i + 2]) * lerpFactor;
                
                // Add gentle breathing effect
                positions[i + 1] += Math.sin(time * 2 + i * 0.1) * 0.1;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            currentState = targetState;
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle photo upload
        function handlePhotoUpload(event) {
            const files = event.target.files;
            if (!files) return;
            
            for (let file of files) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    photos.push(e.target.result);
                };
                reader.readAsDataURL(file);
            }
        }

        // Handle keyboard events
        function onKeyPress(event) {
            switch(event.key.toLowerCase()) {
                case 'h':
                    document.getElementById('ui-overlay').classList.toggle('hidden');
                    break;
                case ' ':
                    targetState = targetState === 'scattered' ? 'gathered' : 'scattered';
                    break;
            }
        }

        // Romantic quotes (Chinese as requested)
        const romanticQuotes = [
            "Áà±ÊòØÂú£ËØûËäÇÁöÑÁúüË∞õÔºåËÄå‰Ω†ÊòØÊàëÁîüÂëΩ‰∏≠ÊúÄÁæéÁöÑÁ§ºÁâ©",
            "ÊØè‰∏Ä‰∏™Á≤íÂ≠êÈÉΩÂú®ËØâËØ¥ÁùÄÊàëÂØπ‰Ω†ÁöÑÊÄùÂøµ",
            "ÊÑøÊàë‰ª¨ÁöÑÁà±ÊÉÖÂ¶ÇÂú£ËØûÊ†ëËà¨ÈïøÈùí‰∏çË¥•",
            "Âú®Ëøô‰∏™ÁâπÂà´ÁöÑÊó•Â≠êÈáåÔºåÂè™ÊÉ≥ÁâµÁùÄ‰Ω†ÁöÑÊâãÁúãÈõ™ËêΩ",
            "‰Ω†ÊòØÊàëÂøÉ‰∏≠ÊúÄ‰∫ÆÁöÑÊòüÔºåÁÖß‰∫ÆÊàëÊâÄÊúâÁöÑÂú£ËØûÂ§ú"
        ];

        // Update romantic message periodically
        setInterval(() => {
            const messageElement = document.querySelector('.romantic-message');
            const randomQuote = romanticQuotes[Math.floor(Math.random() * romanticQuotes.length)];
            messageElement.innerHTML = `"${randomQuote}"<br><br>"Wishing our love shines forever this Christmas üíïüíï"`;
        }, 10000);

        // Initialize application
        window.addEventListener('load', init);
    </script>
</body>
</html>